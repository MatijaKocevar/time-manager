import {
    PrismaClient,
    RequestType,
    RequestStatus,
    ShiftLocation,
    HourType,
} from "../generated/client"
import { SeededRandom, normalizeDate, addDays, dateRange, isWeekday } from "./utils"

export async function seedRequestsForUser(
    prisma: PrismaClient,
    random: SeededRandom,
    userId: string,
    adminUsers: Array<{ id: string; role: string }>,
    endDate: Date,
    holidays: Date[]
) {
    const requestCount = random.nextInt(10, 20)
    const requests = []

    const types: RequestType[] = ["VACATION", "SICK_LEAVE", "WORK_FROM_HOME", "OTHER"]
    const statuses: RequestStatus[] = ["APPROVED", "PENDING", "REJECTED", "CANCELLED"]
    const statusWeights = [60, 20, 15, 5]

    for (let i = 0; i < requestCount; i++) {
        const type = random.choice(types)
        const daysFromNow = random.nextInt(-300, 90)
        const reqStartDate = addDays(endDate, daysFromNow)
        const duration = random.nextInt(1, 10)
        const reqEndDate = addDays(reqStartDate, duration)

        const rand = random.nextInt(0, 99)
        let status: RequestStatus = "PENDING"
        let cumulative = 0
        for (let j = 0; j < statusWeights.length; j++) {
            cumulative += statusWeights[j]
            if (rand < cumulative) {
                status = statuses[j]
                break
            }
        }

        const admin = adminUsers.length > 0 ? random.choice(adminUsers) : null

        const request: {
            userId: string
            type: RequestType
            status: RequestStatus
            startDate: Date
            endDate: Date
            reason: string
            affectsHourType: boolean
            approvedBy?: string
            approvedAt?: Date
            rejectedBy?: string
            rejectedAt?: Date
            rejectionReason?: string
            cancelledBy?: string
            cancelledAt?: Date
            cancellationReason?: string
        } = {
            userId,
            type,
            status,
            startDate: normalizeDate(reqStartDate),
            endDate: normalizeDate(reqEndDate),
            reason: `${type} request`,
            affectsHourType: type === "VACATION" || type === "SICK_LEAVE",
        }

        if (status === "APPROVED" && admin) {
            request.approvedBy = admin.id
            request.approvedAt = new Date(reqStartDate.getTime() - 86400000)
        } else if (status === "REJECTED" && admin) {
            request.rejectedBy = admin.id
            request.rejectedAt = new Date(reqStartDate.getTime() - 86400000)
            request.rejectionReason = "Not enough vacation days"
        } else if (status === "CANCELLED" && admin) {
            request.cancelledBy = random.next() > 0.5 ? userId : admin.id
            request.cancelledAt = new Date(reqStartDate.getTime() - 43200000)
            request.cancellationReason = "Plans changed"
        }

        requests.push(request)
    }

    const createdRequests = []
    for (const request of requests) {
        const created = await prisma.request.create({ data: request })
        createdRequests.push(created)

        if (created.status === "APPROVED" && created.affectsHourType) {
            await seedAutoGeneratedDataForRequest(prisma, created, holidays)
        }
    }

    return createdRequests.length
}

async function seedAutoGeneratedDataForRequest(
    prisma: PrismaClient,
    request: { userId: string; type: RequestType; startDate: Date; endDate: Date },
    holidays: Date[]
) {
    const shifts = []
    const hourEntries = []

    let location: ShiftLocation = "OFFICE"
    let hourType: HourType = "WORK"

    switch (request.type) {
        case "VACATION":
            location = "VACATION"
            hourType = "VACATION"
            break
        case "SICK_LEAVE":
            location = "SICK_LEAVE"
            hourType = "SICK_LEAVE"
            break
        case "WORK_FROM_HOME":
            location = "HOME"
            hourType = "WORK_FROM_HOME"
            break
        case "OTHER":
            location = "OTHER"
            hourType = "OTHER"
            break
    }

    for (const date of dateRange(request.startDate, request.endDate)) {
        if (!isWeekday(date)) continue
        if (holidays.some((h) => h.getTime() === date.getTime())) continue

        shifts.push({
            userId: request.userId,
            date: normalizeDate(date),
            location,
            notes: `Auto-generated from ${request.type} request`,
        })

        if (request.type === "VACATION" || request.type === "SICK_LEAVE") {
            hourEntries.push({
                userId: request.userId,
                date: normalizeDate(date),
                hours: 8,
                type: hourType,
                description: `Auto-generated from ${request.type} request`,
                taskId: null,
            })
        }
    }

    for (const shift of shifts) {
        try {
            await prisma.shift.create({ data: shift })
        } catch {
            // Skip duplicates
        }
    }

    for (const entry of hourEntries) {
        try {
            await prisma.hourEntry.create({ data: entry })
        } catch {
            // Skip duplicates
        }
    }
}
